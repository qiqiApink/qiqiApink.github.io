---
layout: post
title: 30-Days
date: 2018-2-6
author: Qiqi
header-img: img/post-bg-2015.jpg
catalog: true
tag:
   - CTF
   - write up
---

# 30-Days

## Day 1

### 检查符号

**题干：**截取一段电波，一不小心全变成了泡泡。你能够解密吗？ "oooo0。000。ooo。o000。0oooo。0o。0o00。00o。00ooo。o00o。0000o。0oo。0oo。oo000。00oo。oo000。ooo00。ooooo。o0。o000。" 答案格式：key{flag}，flag是解密内容

**相关知识：**古典密码时古代时期人们使用的密码，特征是只会做明文元素的替换和置换。只要知道了加密的算法就能够轻松地破解密文。近代密码加入了机械的帮助，在做明文替换时会使用更加高难度的替换方式，破解起来也会花费更多时间

**解题步骤：**

很容易猜到是摩斯密码，o对应.，0对应-，。对应空格或者/

试着用php脚本替换一下

```php
<?php
  $data = "oooo0。000。ooo。o000。0oooo。0o。0o00。00o。00ooo。o00o。0000o。0oo。0oo。oo000。00oo。oo000。ooo00。ooooo。o0。o000。";
  $data = str_replace("o", ".", $data);
  $data = str_replace("0", "-", $data);
  $data = str_replace("。", " ", $data);
  echo $data
?>
```

或者我们写个python脚本

```python
import re
s = "oooo0。000。ooo。o000。0oooo。0o。0o00。00o。00ooo。o00o。0000o。0oo。0oo。oo000。00oo。oo000。ooo00。ooooo。o0。o000。"
a = ["o", "0", "。"]
b = [".", "-", " "]
dic = dict(zip(a, b))
pattern = re.compile('(' + '|'.join(a) + ')')
s = pattern.sub(lambda a:dic[a.group()], s)
print s
```

输出结果：

**....- --- ... .--- -.... -. -.-- --. --... .--. ----. -.. -.. ..--- --.. ..--- ...-- ..... .- .---**

接着，我们还需要写歌脚本来解密

我直接写了加解密的脚本

```python
def decode(s):
    s = s.split(" ")
    dict = {'.-': 'A',
            '-...': 'B',
            '-.-.': 'C',
            '-..': 'D',
            '.': 'E',
            '..-.': 'F',
            '--.': 'G',
            '....': 'H',
            '..': 'I',
            '.---': 'J',
            '-.-': 'K',
            '.-..': 'L',
            '--': 'M',
            '-.': 'N',
            '---': 'O',
            '.--.': 'P',
            '--.-': 'Q',
            '.-.': 'R',
            '...': 'S',
            '-': 'T',
            '..-': 'U',
            '...-': 'V',
            '.--': 'W',
            '-..-': 'X',
            '-.--': 'Y',
            '--..': 'Z',
            '.----': '1',
            '..---': '2',
            '...--': '3',
            '....-': '4',
            '.....': '5',
            '-....': '6',
            '--...': '7',
            '---..': '8',
            '----.': '9',
            '-----': '0',
            '..--..': '?',
            '-..-.': '/',
            '-.--.-': '()',
            '-....-': '-',
            '.-.-.-': '.'
            }
    str = ''
    for item in s:
        str += dict[item]
    print str.upper() + '\n' + str.lower() + '\n' + str.capitalize() + '\n' + str.title()

def encode(s):
    dict = {'A': '.-',
            'B': '-...',
            'C': '-.-.',
            'D': '-..',
            'E': '.',
            'F': '..-.',
            'G': '--.',
            'H': '....',
            'I': '..',
            'J': '.---',
            'K': '-.-',
            'L': '.-..',
            'M': '--',
            'N': '-.',
            'O': '---',
            'P': '.--.',
            'Q': '--.-',
            'R': '.-.',
            'S': '...',
            'T': '-',
            'U': '..-',
            'V': '-.--',
            'Z': '--..',
            '0': '-----',
            '1': '.----',
            '2': '..---',
            '3': '...--',
            '4': '....-',
            '5': '.....',
            '6': '-....',
            '7': '--...',
            '8': '---..',
            '9': '----.',
            '?': '..--..',
            '/': '-..-.',
            '()': '-.--.-',
            '-': '-....-',
            '.': '.-.-.-'
            }
    for char in s:
        if char == ' ':
            print
        else:
            print dict[char.upper()],

if __name__ == "__main__":
    s = raw_input("please input the string: ")
    c = int(raw_input("encode input 1, decode input 2: "))
    if c == 1:
        encode(s)
    if c == 2:
        decode(s)
```

运行一下，得到

```
4OSJ6NYG7P9DD2Z235AJ
4osj6nyg7p9dd2z235aj
4osj6nyg7p9dd2z235aj
4Osj6Nyg7P9Dd2Z235Aj
```

最终正确答案是key{4osj6nyg7p9dd2z235aj}

## Day 2

### 密钥生成

**题干：**在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17求解出d,格式：key{d}

**相关知识：**

这题考查现代密码学，非对称加密RSA的密钥生成原理

RSA是目前最有影响力和最常用的公钥加密算法

**有关数学知识：**

**1. 互质**

如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是[互质关系](http://zh.wikipedia.org/zh-cn/%E4%BA%92%E7%B4%A0)（coprime）。（即最大公约数是1）

**2. 欧拉函数**

对于给定的正整数，计算比该数小且与该数互质的数的个数的算法就是欧拉函数，用φ(n)表示

简单计算方法：φ(n) = (q - 1) * (p - 1)，p和q是n的两个素因数

**3. 欧拉定理**

[欧拉定理](http://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA))是RSA算法的核心，是[费马小定理](http://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86)的推广

若![n,a](https://wikimedia.org/api/rest_v1/media/math/render/svg/65f10f65fcba30f32673bd2ffe9f8e006f5a624b)为正整数，且![n,a](https://wikimedia.org/api/rest_v1/media/math/render/svg/65f10f65fcba30f32673bd2ffe9f8e006f5a624b)互素（即![\gcd(a,n)=1](https://wikimedia.org/api/rest_v1/media/math/render/svg/0c817b95fb4d50b2b56da323d5a01c7369827df8)），则

![a^{{\varphi (n)}}\equiv 1{\pmod  n}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2e818f3f88d3e71e569f171dd86f31e1903fdc55)

**5. 模反元素**

两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。

可以写成这样：

![ab\equiv 1{\pmod  {n}}.](https://wikimedia.org/api/rest_v1/media/math/render/svg/297023f006cd9486fa4192b391dbc819dd8f89e1)

**密钥生成：**

**第一步：随机选择两个不相等的质数**

比如，选择61和53（现实中，这两个数是非常大的）

**第二步：计算p和q的乘积n**

n = 61 × 53 = 3233

n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。

**第三步：计算n的欧拉函数φ(n)**

根据公式：φ(n) = 60 × 52 = 3120

**第四步：随机选择一个小于n的正整数e，且e与φ(n)互质**

e = 17

**第五步：计算e对于φ(n)的模反元素d**

ed ≡ 1 (mod φ(n))

等价于ed - 1 = kφ(n)

于是，找到模反元素d，实质上就是对下面这个二元一次方程求解

ex + φ(n)y = 1（e = 17，φ(n) = 3120）

17x + 3120y = 1

这个方程可以用["扩展欧几里得算法"](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)求解，解得d = 2753

拓欧算法python脚本如下：

```python
def ext_euclid ( a , b ):
     if (b == 0):
         return 1, 0, a
     else:
         x , y , q = ext_euclid( b , a % b )
         x , y = y, ( x - (a / b) * y )
         return x, y, q
```

**第六步：将n和e封装成公钥，n和d封装成私钥**

公钥：(3233, 17)

私钥：(3233, 2753)

**解题步骤：**

利用上面提到的拓欧算法脚本

```python
def ext_euclid ( a , b ):
     if (b == 0):
         return 1, 0, a
     else:
         x , y , q = ext_euclid( b , a % b )
         x , y = y, ( x - (a / b) * y )
         return x, y, q
         
p=473398607161
q=4511491
e = 17
fn = (p - 1) * (q - 1)
x, y, q = ext_euclid(fn, e)
print y
```

输出：125631357777427553

所以flag是key{125631357777427553}

## Day 3

### RSA解密

**题干：**加密方式好假，rsa直接解密吧~

**相关知识：**RSA加密使用的是公钥密钥对，所以解密将使用对应的私钥对。不过也有使用私钥开始的互动，就是数字签名将使用私钥证明签名的所属性，而大家则可以使用公钥去认证签名。在加密或者签名的过程中，RSA还会使用到密钥生成时的模数N，N与公钥私钥参数e和d组合在一起叫做密钥对

**解题步骤：**

根据提示，rsa解密

打开压缩包，可以看出，有两个文件，一个flag，另一个imhere，flag文件打开，应该是加了密，imhere打开，里面存放着私钥

所以我们使用openssl来解密

```
qiqi@qiqi-Mac ~/Desktop> openssl rsautl -decrypt -in flag -inkey imhere -out flag.txt
```

打开flag.txt便得到了flag：key{c42bcf773d54cf03}

**openssl使用：**

http://man.linuxde.net/openssl

## Day 4

### 公平交易

**题干：**vv公司称，他们给出了最为公平的游戏规则，你能猜到是什么吗？ 规则：FMGKYBXTSFBNCQDSPT，附件：ZKLIPOAGSUMDWFHCBVTRYENXQ. 答案的格式是key{xxxxx}，xxx为解密内容大写，所以答案是

**相关知识：**

根据提示：**公平**

想到了**波雷费密码**（英语：**Playfair cipher**）

加密方法：

1. 选取一个英文字作密钥。除去重复出现的字母。将密钥的字母逐个逐个加入5×5的矩阵内，剩下的空间将未加入的英文字母依a-z的顺序加入（将Q去除，或将I和J视作同一字）
2. 将要加密的讯息分成两个一组。若组内的字母相同，将X（或Q）加到该组的第一个字母后，重新分组。若剩下一个字，也加入X字
3. 在每组中，找出两个字母在矩阵中的地方

- 若两个字母不在同一直行或同一横列，在矩阵中找出另外两个字母，使这四个字母成为一个长方形的四个角（横向优先）
- 若两个字母在同一行，取这两个字母右方的字母（若字母在最右方则取最左方的字母）
- 若两个字母在同一列，取这两个字母下方的字母（若字母在最下方则取最上方的字母）

解密反过来即可

**解题步骤：**

本题密码标如下：

Z	K	L	I	P

O	A	G	S	U

M	D	W	F	H

C	B	V	T	R

Y	E	N	X	Q

密文：FMGKYBXTSFBNCQDSPT

两两一组：

FM	GK	YB	XT	SF	BN	CQ	DS	PT

解密：

WH	 AL	EC	TF	 IS	 VE	 RY	 FA	 IR

所以flag就是：key{WHALECTFISVERYFAIR}

我们也可以使用python第三方库pycipher中的Playfair来解密

```python
>>> from pycipher import Playfair
>>> Playfair('ZKLIPOAGSUMDWFHCBVTRYENXQ').decipher('FMGKYBXTSFBNCQDSPT')
'WHALECTFISVERYFAIR'
```

我们也可以自己写一个python脚本

```python
#coding:utf-8

str_1 = raw_input("input the 25 letters: ") # 25位，写成5*5的密码表
str_2 = ""
str_3 = ""
str_4 = "abcdefghiklmnopqrstuvwxyz" #去掉 j 因为ij在一起
str_5 = ""
str_6 = raw_input("input the rule: ") #要解密的规则  两两分组
list_1 = []
str_7 = ""

def zhongheng(abc, adc):
    a = 0
    x1 = ""
    y1= ''
    x2 = ""
    y2 = ""
    for i in list_1:
        i = list(i)
        if abc in i:
            x1 = a
            y1 = i.index(abc)

        else:
            pass
        if adc in i:
            x2 = a
            y2 = i.index(adc)
        else:
            pass
        a += 1
    print x1, y1, x2, y2

    if x1 == x2:
        if y1 == 0 and y2 == 0:
            return str(list_1[x1][4]) + str(list_1[x2][4])
        if y1 == 0 and y2 != 0:
            return str(list_1[x1][4]) + str(list_1[x2][y2 - 1])
        if y1 != 0 and y2 == 0:
            return str(list_1[x1][y1 - 1]) + str(list_1[x2][4])
        else:
            return str(list_1[x1][y1 - 1]) + str(list_1[x2][y2 - 1])

    if y1 == y2:
        if x1 == 0 and x2 == 0:
            return str(list_1[4][y2]) + str(list_1[4][y2])
        if x1 == 0 and x2 != 0:
            return str(list_1[4][y1]) + str(list_1[x2 - 1][y2])
        if x1 != 0 and x2 == 0:
            return str(list_1[x1 - 1][y1])+ str(list_1[4][y2])
        else:
            return str(list_1[x1 - 1][y1]) + str(list_1[x2 - 1][y2])

    aaie = str(list_1[x1][y2]) + str(list_1[x2][y1])
    return aaie


#去除空格
for i in str_1:
    str_2 += i.strip(" ")

#去掉重复和j
for i in str_2:
    if i in str_3:
        pass
    elif i == "j":
        pass
    else:
        str_3 += i

#填完密钥出现的字母后，若还有空余，就填字母表中剩余的字母（按字母表顺序）
for i in str_4:
    if i in str_3:
        pass
    else:
        str_5 += i
str_3 += str_5

flag = ""

#分为 5x5 的数组
for i in range(5):
    list_1.append(str_3[i * 5 : i * 5 + 5])

for i in range(0, len(str_6), 2):
    flag += zhongheng(str(str_6[i]), str(str_6[i+1]))
print "flag: " + flag
```

跑一下，也能得到相同的结果

## Day 5

### 填空题

**题干：**拿到一个填空题，到底该填什么？答案的格式是key{xxxxx}，所以答案是

**相关知识：**目前大家使用的编码为utf-8，这也是使用8位自然存储位的编码方式，各类web应用以及计算机存储都会使用这类编码，还有更新的utf编码格式吗？

**解题步骤：**

没有任何提示，百度一下rfc4042，得知是utf9或者utf18编码的

所以先安装个utf9库

python解一下

```python
import utf9
f = open('flag_is_here_rfc4042', 'rb')
s = ''
for line in f:
    s += line
    
print utf9.utf9decode(s)
```

得到：

```
_____*((__//__+___+______-____%____)**((___%(___-_))+________+(___%___+_____+_______%__+______-(______//(_____%___)))))+__*(((________/__)+___%__+_______-(________//____))**(_*(_____+_____)+_______+_________%___))+________*(((_________//__+________%__)+(_______-_))**((___+_______)+_________-(______//__)))+_______*((___+_________-(______//___-_______%__%_))**(_____+_____+_____))+__*(__+_________-(___//___-_________%_____%__))**(_________-____+_______)+(___+_______)**(________%___%__+_____+______)+(_____-__)*((____//____-_____%____%_)+_________)**(_____-(_______//_______+_________%___)+______)+(_____+(_________%_______)*__+_)**_________+_______*(((_________%_______)*__+_______-(________//________))**_______)+(________/__)*(((____-_+_______)*(______+____))**___)+___*((__+_________-_)**_____)+___*(((___+_______-______/___+__-_________%_____%__)*(___-_+________/__+_________%_____))**__)+(_//_)*(((________%___%__+_____+_____)%______)+_______-_)**___+_____*((______/(_____%___))+_______)*((_________%_______)*__+_____+_)+___//___+_________+_________/___
```

感觉应该是数学表达式，猜想下划线的个数代表数字，这样就能构成数学算式

再写个脚本，计算一下结果

```python
s = '_____*((__//__+___+______-____%____)**((___%(___-_))+________+(___%___+_____+_______%__+______-(______//(_____%___)))))+__*(((________/__)+___%__+_______-(________//____))**(_*(_____+_____)+_______+_________%___))+________*(((_________//__+________%__)+(_______-_))**((___+_______)+_________-(______//__)))+_______*((___+_________-(______//___-_______%__%_))**(_____+_____+_____))+__*(__+_________-(___//___-_________%_____%__))**(_________-____+_______)+(___+_______)**(________%___%__+_____+______)+(_____-__)*((____//____-_____%____%_)+_________)**(_____-(_______//_______+_________%___)+______)+(_____+(_________%_______)*__+_)**_________+_______*(((_________%_______)*__+_______-(________//________))**_______)+(________/__)*(((____-_+_______)*(______+____))**___)+___*((__+_________-_)**_____)+___*(((___+_______-______/___+__-_________%_____%__)*(___-_+________/__+_________%_____))**__)+(_//_)*(((________%___%__+_____+_____)%______)+_______-_)**___+_____*((______/(_____%___))+_______)*((_________%_______)*__+_____+_)+___//___+_________+_________/___'
ul = s[0]
cnt = 0
exp = ''
for i in s:
    if i is ul:
        cnt += 1
    else:
        if cnt != 0:
            exp += str(cnt)
            cnt = 0
            exp += i
        else:
            exp += i
if cnt != 0:
	exp += str(cnt)
exp = exp.replace('//', '/')
print exp
key = eval(exp)
print key
```

得到算式：

```
5*((2/2+3+6-4%4)**((3%(3-1))+8+(3%3+5+7%2+6-(6/(5%3)))))+2*(((8/2)+3%2+7-(8/4))**(1*(5+5)+7+9%3))+8*(((9/2+8%2)+(7-1))**((3+7)+9-(6/2)))+7*((3+9-(6/3-7%2%1))**(5+5+5))+2*(2+9-(3/3-9%5%2))**(9-4+7)+(3+7)**(8%3%2+5+6)+(5-2)*((4/4-5%4%1)+9)**(5-(7/7+9%3)+6)+(5+(9%7)*2+1)**9+7*(((9%7)*2+7-(8/8))**7)+(8/2)*(((4-1+7)*(6+4))**3)+3*((2+9-1)**5)+3*(((3+7-6/3+2-9%5%2)*(3-1+8/2+9%5))**2)+(1/1)*(((8%3%2+5+5)%6)+7-1)**3+5*((6/(5%3))+7)*((9%7)*2+5+1)+3/3+9+9/3
```

key算出来是：5287002131074331513

瞎捣鼓了半天，发现应该将key转为16进制，再转为字符

```python
key = 5287002131074331513
hk = hex(key)[2:]
ck = ''
for i in range(len(hk) / 2):
	ck += chr(int(hk[i * 2 : i * 2 + 2], 16))
print ck
```

运行一下得到

```
I_4m-k3y
```

所以flag就是key{I_4m-k3y}

## Day 6

### RSA破解

**题干：**得到了公钥，怎么才能解密呢？tip分解n，答案格式whalectf{flag}

**相关知识：**质因数分解问题是困难的，但是可以通过计算机进行暴力分解。1999年，名为Cary的超级计算机用5个月的时间分解了512bit的n。2009年，一群研究人员成功分解了768bit的n。2010年，又提出了一些针对1024bit的n分解的途径，但是没有正面分解成功。目前只要是小于256bit的n用我们的私人计算机就可以很快分解，人们一直在努力攻破RSA

**解题步骤：**

使用openssl解析公钥文件得到模数和公钥

```
qiqi@qiqi-Mac ~/Desktop> openssl rsa -pubin -text -modulus -in public.pem
Modulus (256 bit):
    00:ca:00:f5:ed:7b:33:b9:bd:42:1e:77:31:8a:a1:
    78:e7:5d:ed:e3:cb:1b:c7:d4:7a:7d:14:3b:e7:49:
    1c:90:25
Exponent: 65537 (0x10001)
Modulus=CA00F5ED7B33B9BD421E77318AA178E75DEDE3CB1BC7D47A7D143BE7491C9025
writing RSA key
-----BEGIN PUBLIC KEY-----
MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMoA9e17M7m9Qh53MYqheOdd7ePLG8fU
en0UO+dJHJAlAgMBAAE=
-----END PUBLIC KEY-----
```

公钥：`65537 (0x10001)`

模数：`CA00F5ED7B33B9BD421E77318AA178E75DEDE3CB1BC7D47A7D143BE7491C9025`

转换为十进制：`91368892744156824784111061767736072407911145707607105701466887321431798747173`

使用在线分解网站：`http://factordb.com/`

p = `290579950064240059571837821251441436997`

q = `314436328879392457343835667929324128609`

然后写个python脚本解密：

```python
import gmpy2

p = 290579950064240059571837821251441436997
q = 314436328879392457343835667929324128609
e = 65537

f = int(open('flag.enc', 'rb').read().encode('hex'), 16)
print f
n = p * q
fn = (p - 1) * (q - 1)
d = gmpy2.invert(e, fn)
h = hex(gmpy2.powmod(f, d, n))[2:]
if len(h) % 2 == 1:
    h = '0' + h
s = h.decode('hex')
print s
```

运行一下得到：whalectf{256_n_get}

## Day 7

### 雨中龙猫

**题干：**下base雨了，龙猫在雨中很开心的跳跃着，它说雨中能看见答案，答案有27条街那么长，最后一条街叫做py。答案格式为whalectf{xxx}

**相关知识：**base64编码是从二进制到字符的过程，可以用在http环境下传输较长的标识信息，将字母的ascii码(8)位重新分组为6位后，在由大小写字母，数字以及+和／组成的编码表中重新编码组成

**解题步骤：**

这题的坑都是自己给自己挖的，完全误解了题目意思，最后还是请教了大佬，发现自己就是给自己挖坑，然后往里跳

其实这题很简单，我们将`whalectf{`和`py}`进行base64编码，然后把图片用16进制查看器打开，查找编码后的结果`d2hhbGVjdGZ7`和`cHl9`，因为答案长度27，是3的倍数，所以编码后的结果一定存在于整个答案编码的结果中，所以直接查询，得到两串base64编码的字符串，拼接到一起，得到`d2hhbGVjdGZ7TG9uZ19tYW9faXNfaGFwcHl9`

解码，得到`whalectf{Long_mao_is_happy}`

## Day 8

### 鲸鱼日记

**题干：**鲸鱼去世了沉入海底，只留下了生前的一张照片。人们都说鲸鱼会写日记，找到日记就能找到他的宝藏，你能找到吗？答案格式：whale{xxx}

**相关知识：**jpeg图片头为00d8ff00，而紧跟其后还有很多描述性的文件头部分，在这些部分中插入信息是不会影响图片打开或者解析的

**解题思路：**

丢到binwalk里看一下，发现好多zip的文件，用foremost分离一下，得到一个word文档，打开，一篇英文日记

猜想应该是隐藏文字，所以显示隐藏文字，发现每一行的结尾都多了一个字符，从上到下读取一下，whale{lovesea}，就是本题的flag

## Day 9

### 追加数据

**题干：**蓝鲸安全压缩数据被人篡改！文件最后竟然加上了塔主签名！请找到被篡改部分，答案格式：whale{xxx}

**相关知识：**PNG图片是通过IDAT块来保存图片信息的。通常有两种保存方法，一种是将所有图片信息保存到一个IDAT块中，通常会使用这种方法，但是这样保存的IDAT块会很大。第二种方法是将图片信息压缩奇=后等长地将其分解为连续的IDAT块保存，这样保存的IDAT长度除了最后一块都一样长

**解题步骤：**

使用pngcheck分析一下图片

```
qiqi@qiqi-Mac ~/Desktop> pngcheck -v whalectf.png
File: whalectf.png (95258 bytes)
  chunk IHDR at offset 0x0000c, length 13
    1017 x 250 image, 32-bit RGB+alpha, non-interlaced
  chunk pHYs at offset 0x00025, length 9: 11811x11811 pixels/meter (300 dpi)
  chunk tEXt at offset 0x0003a, length 25, keyword: Software
  chunk IDAT at offset 0x0005f, length 94938
    zlib: deflated, 32K window, maximum compression
  chunk IDAT at offset 0x17345, length 193
  chunk IEND at offset 0x17412, length 0
No errors detected in whalectf.png (6 chunks, 90.6% compression).
```

我们看到一共两个IDAT块，第一个IDAT块的长度超过了65524，所以存储方式应该是只选用一个IDAT块，那么第二个IDAT块显然就是认为添加的了

用16进制编辑器打开，找到偏移量为0x17345的地方，发现是IDAT的标识位，于是我们从IDAT块的起始位置往后找193个长度，得到：

```
789CA552B911C3300C5B09D87FB99C65E2A11A17915328FC8487C0C7E17BCEF57CCFAFA27CAB749B8A8E3E754C4C15EF25F934CDFF9DD7C0D413EB7D9E18D16F15D2EB0B2BF1D44C6AE6CAB1664F11933436A9D0D8AA6B5A2D09BA785E58EC8AB264111C0330A148170B90DA0E582CF388073676D2022C50CA86B63175A3FD26AE1ECDF2C658D148E0391591C9916A795432FBDDF27F6D2B71476C6C361C052FAA846A91B22C76A25878681B7EA904A950E28887562FDBC59AF6DFF901E0DBC1AB
```

而png图片的压缩方式是zlib，所以我们写个python脚本解压一下

```python
#coding:utf-8

import zlib
import binascii

IDAT = "789CA552B911C3300C5B09D87FB99C65E2A11A17915328FC8487C0C7E17BCEF57CCFAFA27CAB749B8A8E3E754C4C15EF25F934CDFF9DD7C0D413EB7D9E18D16F15D2EB0B2BF1D44C6AE6CAB1664F11933436A9D0D8AA6B5A2D09BA785E58EC8AB264111C0330A148170B90DA0E582CF388073676D2022C50CA86B63175A3FD26AE1ECDF2C658D148E0391591C9916A795432FBDDF27F6D2B71476C6C361C052FAA846A91B22C76A25878681B7EA904A950E28887562FDBC59AF6DFF901E0DBC1AB".decode('hex')

result = binascii.hexlify(zlib.decompress(IDAT))
bin = result.decode('hex')

print bin
print '\r\n'
print len(bin)
```

运行一下：

```
0000000000000000000000000000000001111111000010101001000111111100010000010001000010100101000001000101110101010000011010010111010001011101011010000010110101110100010111010000001001011101011101000100000100110111100101010000010001111111010101010101010111111100000000000101011101100100000000000000010111111001010110110011000000101100001001000100001101000100000001010110111101100011101010000001101000111110011101011101000001001011100110101100101111011000000010101111010110101100101000000011110110010000000111111011110000110000010101101001111000101000011100011100111010011000101110000100110010111111000101000001000001110001100010111000110011100100001011101100111111001110000101000111001110001001101101111100110000000000010010101101110001110000011111110111000100000101010111000100000100101101101001000111000001011101011110001001011111101100010111010011000110111101001110000101110100100100000011010101000001000001001110110110011100101100011111110010000100001110100100000000000000000000000000000000000000000000000000000000000000000000


1024
```

一串01字符串，长度是1024，是32的平方，猜测可能是个二维码

所以我们写个脚本来生成一下，试一试

```python
from PIL import Image

MAX = 32
pic = Image.new("RGB", (MAX, MAX))
str = "0000000000000000000000000000000001111111000010101001000111111100010000010001000010100101000001000101110101010000011010010111010001011101011010000010110101110100010111010000001001011101011101000100000100110111100101010000010001111111010101010101010111111100000000000101011101100100000000000000010111111001010110110011000000101100001001000100001101000100000001010110111101100011101010000001101000111110011101011101000001001011100110101100101111011000000010101111010110101100101000000011110110010000000111111011110000110000010101101001111000101000011100011100111010011000101110000100110010111111000101000001000001110001100010111000110011100100001011101100111111001110000101000111001110001001101101111100110000000000010010101101110001110000011111110111000100000101010111000100000100101101101001000111000001011101011110001001011111101100010111010011000110111101001110000101110100100100000011010101000001000001001110110110011100101100011111110010000100001110100100000000000000000000000000000000000000000000000000000000000000000000"

i = 0
for y in range(0, MAX):
    for x in range(0, MAX):
        if(str[i] == '1'):
            pic.putpixel([x, y], (0, 0, 0))
        else:
            pic.putpixel([x, y], (255, 255, 255))
        i = i + 1

pic.show()
pic.save("flag.png")
```

运行一下，真的得到了一个二维码，扫一下得到whale{QR_code_and_png}

## Day 10

### 破碎的心

**题干：**鲸鱼的心被撕碎了，你能把它拼好吗？答案格式,whale{flag}，flag是解密内容

**相关知识：**

条形码一共有8个区域：左侧空白区 -> 起始符 -> 左侧数据符 -> 中间分隔符 -> 右侧数据符 -> 校验符 -> 终止符 -> 右侧空白区

![](http://before.barcodebm.com/upload/20121205104338_76460.png)

字符为0～9

除空白区外的区域和字符都采用二进制编码表示，1表示bar（黑条），0表示space（白条）

起始符，终止符编码为101，分隔符编码为01010

0～9每种字符有3种编码方式AB为左侧数据奇偶编码，C为右侧数据偶编码

**解题步骤：**

打开题目给的图片，是一个不完整的条形码，一懵，没有ps，也不会写脚本

于是我便打开windows虚拟机，用画图工具截取然后shift+⬆️，得到一个完整的条形码

扫一下得到flag：whale{BarC0d3_Pick}

如果没有离线工具，也可以使用在线工具：[条形码在线扫描](https://jiema.wwei.cn/)

## Day 11

### 我们不一样

**题干：**两条孪生鲸鱼兄弟长得一模一样，他们却非说他们不一样。原来在鲸鱼弟弟的尾巴上有一条小小的胎记，你能找到吗？答案格式whale{xxxx}

**相关知识：**

图片和屏幕现在使用最多的颜色表示标准为RGB编码，该编码方式通过控制每一个图片像素点的RGB三原色强度来控制每个像素点的颜色

**解题步骤：**

扔binwalk里看一下

```
qiqi@qiqi-Mac ~/Desktop> binwalk whale.png

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             PNG image, 2000 x 2661, 8-bit/color RGB, non-interlaced
85            0x55            Zlib compressed data, best compression
2755          0xAC3           Zlib compressed data, best compression
3537597       0x35FABD        PNG image, 2000 x 2661, 8-bit/color RGB, non-interlaced
3537651       0x35FAF3        Zlib compressed data, default compression
3540259       0x360523        Zlib compressed data, default compression

```

发现有两张图片

用foremost分离一下得到两张看上去一模一样的图片

使用stegsolve对比两张图片并进行XOR，导出，用16进制编辑器查

```
002C00002D00002C00002C00002D00002C00002F00002F00002E00002F00002F00002E00002C00002D00002D00002D00002D00002C00002C00002D00002D00002D00002D00002C00002D00002C00002C00002D00002C00002C00002D00002D00002D00002C00002C00002D00002D00002C00002D00002C00002D00002C00002C00002C00002C00002D00002C00002C00002E00002F00002F00002F00002E00002F00002F00002F00002E00002E00002F00002F00002E00002E00002F00002F00002E00002F00002E00002F00002F00002F00002F00002F00002E00002F00002F00002E00002E00002E00002E00002F00002E00002F00002F00002F00002E00002E00002F00002E00002E00002E00002F00002F00002E00002E00002F00002F00002E00002F00002E00002F00002F00002F00002F00002F00002E00002F00002F00002E00002E00002F00002E00002E00002E00002E00002F00002F00002D00002D00002D00002C00002D00002C00002C00002D00002C00002D00002D00002C00002D00002C00002C00002D00002D00002C00002C00002D00002D00002C00002C00002D00002D00002C00002D00002C00002C00002C00002D00002D00002C00002C00002D00002C00002C00002D00002D00002C00002C00002D00002C00002D00002C00002D00002D00002C00002A00002A00002A00002B00002B00002B00002A00002A00002B00002A00002B00002B00002A00002B00002B00002B00002A00002A00002B00002A
```

这样一段存在差异

使用python将差异部分进行提取

```python
from PIL import Image

img1 = Image.open("1.png")
im1 = img1.load()
img2 = Image.open("2.png")
im2 = img2.load()

for x in range(img1.size[0]):
	for y in range(img1.size[1]):
    	if(im1[x, y] != im2[x, y]):
        	print im1[x, y], im2[x, y]
```

运行一下，得到

```
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(6, 3, 46) (6, 3, 1)
(6, 3, 46) (6, 3, 1)
(6, 3, 46) (6, 3, 0)
(6, 3, 46) (6, 3, 1)
(6, 3, 46) (6, 3, 1)
(6, 3, 46) (6, 3, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(3, 2, 44) (3, 2, 0)
(3, 2, 44) (3, 2, 1)
(3, 2, 44) (3, 2, 1)
(3, 2, 44) (3, 2, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(3, 2, 44) (3, 2, 0)
(3, 2, 44) (3, 2, 0)
(3, 2, 44) (3, 2, 1)
(3, 2, 44) (3, 2, 1)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 1)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 1)
(4, 1, 44) (4, 1, 1)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 1)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 1)
(3, 2, 44) (3, 2, 0)
(3, 2, 44) (3, 2, 1)
(3, 2, 44) (3, 2, 1)
(3, 2, 44) (3, 2, 0)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 0)
(2, 1, 43) (2, 1, 0)
(2, 1, 43) (2, 1, 0)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 0)
(2, 1, 43) (2, 1, 1)
(1, 0, 42) (1, 0, 1)
(1, 0, 42) (1, 0, 1)
(1, 0, 42) (1, 0, 0)
(1, 0, 42) (1, 0, 1)
(1, 0, 42) (1, 0, 1)
(1, 0, 42) (1, 0, 1)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 0)
(2, 1, 43) (2, 1, 1)
```

发现前两位都一样，但最后一位存在差异，而且第二章图片的最后一位都是0或者1，猜想可能隐藏了数据

所以我们要把01段提取出来，8位一组，转为字符，得到字符串，应该就是flag

所以我们修改一下上面的脚本

```python
from PIL import Image
import binascii
import re

img1 = Image.open("1.png")
im1 = img1.load()
img2 = Image.open("2.png")
im2 = img2.load()

s=''

for x in range(img1.size[0]):
    for y in range(img1.size[1]):
        if(im1[x, y] != im2[x, y]):
            s = s + str(im2[x, y][2])

s = str.strip(re.sub(r'(\d{8})', r'\1 ', s))
a = ''.join([chr(i) for i in [int(b, 2) for b in s.split(' ')]])
lista = ''.join(a)
print lista
```

运行一下得到whale{w3_ar3_d1ffe2en7}

## Day 12

### 黑白打字机

**题干：**仔细看看图片，答案的格式是venusctf{xxxxx}，所以答案是

**相关知识：**

五笔输入法时中国、台湾、日本等利用结构字体书写的国家根据字体字根发明的一种输入法。我们将键盘上的按键映射到不同字体的字根，如横、竖等。最终只需要记忆每个字的字根病熟练练习就能比拼音输入法更快的输入汉字。而最正宗的五笔编码的86版的王码编码

**解题步骤：**

那道题目是一张被反色了的二维码图片，用画图工具进行反色，扫描二维码，得到：你会五笔吗

猜想应该要将这五个字编码为五笔，得到`wqiywfcugghgttfnkcg`

之后注意到文件名很可疑，倒过来读发现是steganography

所以我们要借助工具`image steganography`来帮助我们解密文件

直接解密发现解出来是一堆乱码，于是我们要用到decrypt功能，弹出一个password窗口，猜想刚才的五笔编码可能就是password

尝试输入，成功得到flag：venusctf{V3nus_St3gan0graph1_1s_g00d}
