---
layout: post
title: 30-Days
date: 2018-2-6
author: Qiqi
header-img: img/post-bg-2015.jpg
catalog: true
tag:
   - CTF
   - write up
---

# 30-Days

## Day 1

### 检查符号

**题干：**截取一段电波，一不小心全变成了泡泡。你能够解密吗？ "oooo0。000。ooo。o000。0oooo。0o。0o00。00o。00ooo。o00o。0000o。0oo。0oo。oo000。00oo。oo000。ooo00。ooooo。o0。o000。" 答案格式：key{flag}，flag是解密内容

**解题步骤：**

很容易猜到是摩斯密码，o对应.，0对应-，。对应空格或者/

试着用php脚本替换一下

```php
<?php
  $data = "oooo0。000。ooo。o000。0oooo。0o。0o00。00o。00ooo。o00o。0000o。0oo。0oo。oo000。00oo。oo000。ooo00。ooooo。o0。o000。";
  $data = str_replace("o", ".", $data);
  $data = str_replace("0", "-", $data);
  $data = str_replace("。", " ", $data);
  echo $data
?>
```

或者我们写个python脚本

```python
import re
s = "oooo0。000。ooo。o000。0oooo。0o。0o00。00o。00ooo。o00o。0000o。0oo。0oo。oo000。00oo。oo000。ooo00。ooooo。o0。o000。"
a = ["o", "0", "。"]
b = [".", "-", " "]
dic = dict(zip(a, b))
pattern = re.compile('(' + '|'.join(a) + ')')
s = pattern.sub(lambda a:dic[a.group()], s)
print s
```

输出结果：

**....- --- ... .--- -.... -. -.-- --. --... .--. ----. -.. -.. ..--- --.. ..--- ...-- ..... .- .---**

接着，我们还需要写歌脚本来解密

我直接写了加解密的脚本

```python
def decode(s):
    s = s.split(" ")
    dict = {'.-': 'A',
            '-...': 'B',
            '-.-.': 'C',
            '-..': 'D',
            '.': 'E',
            '..-.': 'F',
            '--.': 'G',
            '....': 'H',
            '..': 'I',
            '.---': 'J',
            '-.-': 'K',
            '.-..': 'L',
            '--': 'M',
            '-.': 'N',
            '---': 'O',
            '.--.': 'P',
            '--.-': 'Q',
            '.-.': 'R',
            '...': 'S',
            '-': 'T',
            '..-': 'U',
            '...-': 'V',
            '.--': 'W',
            '-..-': 'X',
            '-.--': 'Y',
            '--..': 'Z',
            '.----': '1',
            '..---': '2',
            '...--': '3',
            '....-': '4',
            '.....': '5',
            '-....': '6',
            '--...': '7',
            '---..': '8',
            '----.': '9',
            '-----': '0',
            '..--..': '?',
            '-..-.': '/',
            '-.--.-': '()',
            '-....-': '-',
            '.-.-.-': '.'
            }
    str = ''
    for item in s:
        str += dict[item]
    print str.upper() + '\n' + str.lower() + '\n' + str.capitalize() + '\n' + str.title()

def encode(s):
    dict = {'A': '.-',
            'B': '-...',
            'C': '-.-.',
            'D': '-..',
            'E': '.',
            'F': '..-.',
            'G': '--.',
            'H': '....',
            'I': '..',
            'J': '.---',
            'K': '-.-',
            'L': '.-..',
            'M': '--',
            'N': '-.',
            'O': '---',
            'P': '.--.',
            'Q': '--.-',
            'R': '.-.',
            'S': '...',
            'T': '-',
            'U': '..-',
            'V': '-.--',
            'Z': '--..',
            '0': '-----',
            '1': '.----',
            '2': '..---',
            '3': '...--',
            '4': '....-',
            '5': '.....',
            '6': '-....',
            '7': '--...',
            '8': '---..',
            '9': '----.',
            '?': '..--..',
            '/': '-..-.',
            '()': '-.--.-',
            '-': '-....-',
            '.': '.-.-.-'
            }
    for char in s:
        if char == ' ':
            print
        else:
            print dict[char.upper()],

if __name__ == "__main__":
    s = raw_input("please input the string: ")
    c = int(raw_input("encode input 1, decode input 2: "))
    if c == 1:
        encode(s)
    if c == 2:
        decode(s)
```

运行一下，得到

```
4OSJ6NYG7P9DD2Z235AJ
4osj6nyg7p9dd2z235aj
4osj6nyg7p9dd2z235aj
4Osj6Nyg7P9Dd2Z235Aj
```

最终正确答案是key{4osj6nyg7p9dd2z235aj}

## Day 2

### 密钥生成

**题干：**在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17求解出d,格式：key{d}

**相关知识：**

这题考查现代密码学，非对称加密RSA的密钥生成原理

RSA是目前最有影响力和最常用的公钥加密算法

**有关数学知识：**

**1. 互质**

如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是[互质关系](http://zh.wikipedia.org/zh-cn/%E4%BA%92%E7%B4%A0)（coprime）。（即最大公约数是1）

**2. 欧拉函数**

对于给定的正整数，计算比该数小且与该数互质的数的个数的算法就是欧拉函数，用φ(n)表示

简单计算方法：φ(n) = (q - 1) * (p - 1)，p和q是n的两个素因数

**3. 欧拉定理**

[欧拉定理](http://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA))是RSA算法的核心，是[费马小定理](http://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86)的推广

若![n,a](https://wikimedia.org/api/rest_v1/media/math/render/svg/65f10f65fcba30f32673bd2ffe9f8e006f5a624b)为正整数，且![n,a](https://wikimedia.org/api/rest_v1/media/math/render/svg/65f10f65fcba30f32673bd2ffe9f8e006f5a624b)互素（即![\gcd(a,n)=1](https://wikimedia.org/api/rest_v1/media/math/render/svg/0c817b95fb4d50b2b56da323d5a01c7369827df8)），则

![a^{{\varphi (n)}}\equiv 1{\pmod  n}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2e818f3f88d3e71e569f171dd86f31e1903fdc55)

**5. 模反元素**

两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。

可以写成这样：

![ab\equiv 1{\pmod  {n}}.](https://wikimedia.org/api/rest_v1/media/math/render/svg/297023f006cd9486fa4192b391dbc819dd8f89e1)

**密钥生成：**

**第一步：随机选择两个不相等的质数**

比如，选择61和53（现实中，这两个数是非常大的）

**第二步：计算p和q的乘积n**

n = 61 × 53 = 3233

n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。

**第三步：计算n的欧拉函数φ(n)**

根据公式：φ(n) = 60 × 52 = 3120

**第四步：随机选择一个小于n的正整数e，且e与φ(n)互质**

e = 17

**第五步：计算e对于φ(n)的模反元素d**

ed ≡ 1 (mod φ(n))

等价于ed - 1 = kφ(n)

于是，找到模反元素d，实质上就是对下面这个二元一次方程求解

ex + φ(n)y = 1（e = 17，φ(n) = 3120）

17x + 3120y = 1

这个方程可以用["扩展欧几里得算法"](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)求解，解得d = 2753

拓欧算法python脚本如下：

```python
def ext_euclid ( a , b ):
     if (b == 0):
         return 1, 0, a
     else:
         x , y , q = ext_euclid( b , a % b )
         x , y = y, ( x - (a / b) * y )
         return x, y, q
```

**第六步：将n和e封装成公钥，n和d封装成私钥**

公钥：(3233, 17)

私钥：(3233, 2753)

**解题步骤：**

利用上面提到的拓欧算法脚本

```python
def ext_euclid ( a , b ):
     if (b == 0):
         return 1, 0, a
     else:
         x , y , q = ext_euclid( b , a % b )
         x , y = y, ( x - (a / b) * y )
         return x, y, q
         
p=473398607161
q=4511491
e = 17
fn = (p - 1) * (q - 1)
x, y, q = ext_euclid(fn, e)
print y
```

输出：125631357777427553

所以flag是key{125631357777427553}

## Day 3

### RSA解密

**题干：**加密方式好假，rsa直接解密吧~

**解题步骤：**

根据提示，rsa解密

打开压缩包，可以看出，有两个文件，一个flag，另一个imhere，flag文件打开，应该是加了密，imhere打开，里面存放着私钥

所以我们使用openssl来解密

```
qiqi@qiqi-Mac ~/Desktop> openssl rsautl -decrypt -in flag -inkey imhere -out flag.txt
```

打开flag.txt便得到了flag：key{c42bcf773d54cf03}

**相关知识：**

openssl使用：

http://man.linuxde.net/openssl

## Day 4

### 公平交易

**题干：**vv公司称，他们给出了最为公平的游戏规则，你能猜到是什么吗？ 规则：FMGKYBXTSFBNCQDSPT，附件：ZKLIPOAGSUMDWFHCBVTRYENXQ. 答案的格式是key{xxxxx}，xxx为解密内容大写，所以答案是

**相关知识：**

根据提示：**公平**

想到了**波雷费密码**（英语：**Playfair cipher**）

加密方法：

1. 选取一个英文字作密钥。除去重复出现的字母。将密钥的字母逐个逐个加入5×5的矩阵内，剩下的空间将未加入的英文字母依a-z的顺序加入（将Q去除，或将I和J视作同一字）
2. 将要加密的讯息分成两个一组。若组内的字母相同，将X（或Q）加到该组的第一个字母后，重新分组。若剩下一个字，也加入X字
3. 在每组中，找出两个字母在矩阵中的地方

- 若两个字母不在同一直行或同一横列，在矩阵中找出另外两个字母，使这四个字母成为一个长方形的四个角（横向优先）
- 若两个字母在同一行，取这两个字母右方的字母（若字母在最右方则取最左方的字母）
- 若两个字母在同一列，取这两个字母下方的字母（若字母在最下方则取最上方的字母）

解密反过来即可

**解题步骤：**

本题密码标如下：

Z	K	L	I	P

O	A	G	S	U

M	D	W	F	H

C	B	V	T	R

Y	E	N	X	Q

密文：FMGKYBXTSFBNCQDSPT

两两一组：

FM	GK	YB	XT	SF	BN	CQ	DS	PT

解密：

WH	 AL	EC	TF	 IS	 VE	 RY	 FA	 IR

所以flag就是：key{WHALECTFISVERYFAIR}

我们也可以使用python第三方库pycipher中的Playfair来解密

```python
>>> from pycipher import Playfair
>>> Playfair('ZKLIPOAGSUMDWFHCBVTRYENXQ').decipher('FMGKYBXTSFBNCQDSPT')
'WHALECTFISVERYFAIR'
```

我们也可以自己写一个python脚本

```python
#coding:utf-8

str_1 = raw_input("input the 25 letters: ") # 25位，写成5*5的密码表
str_2 = ""
str_3 = ""
str_4 = "abcdefghiklmnopqrstuvwxyz" #去掉 j 因为ij在一起
str_5 = ""
str_6 = raw_input("input the rule: ") #要解密的规则  两两分组
list_1 = []
str_7 = ""

def zhongheng(abc, adc):
    a = 0
    x1 = ""
    y1= ''
    x2 = ""
    y2 = ""
    for i in list_1:
        i = list(i)
        if abc in i:
            x1 = a
            y1 = i.index(abc)

        else:
            pass
        if adc in i:
            x2 = a
            y2 = i.index(adc)
        else:
            pass
        a += 1
    print x1, y1, x2, y2

    if x1 == x2:
        if y1 == 0 and y2 == 0:
            return str(list_1[x1][4]) + str(list_1[x2][4])
        if y1 == 0 and y2 != 0:
            return str(list_1[x1][4]) + str(list_1[x2][y2 - 1])
        if y1 != 0 and y2 == 0:
            return str(list_1[x1][y1 - 1]) + str(list_1[x2][4])
        else:
            return str(list_1[x1][y1 - 1]) + str(list_1[x2][y2 - 1])

    if y1 == y2:
        if x1 == 0 and x2 == 0:
            return str(list_1[4][y2]) + str(list_1[4][y2])
        if x1 == 0 and x2 != 0:
            return str(list_1[4][y1]) + str(list_1[x2 - 1][y2])
        if x1 != 0 and x2 == 0:
            return str(list_1[x1 - 1][y1])+ str(list_1[4][y2])
        else:
            return str(list_1[x1 - 1][y1]) + str(list_1[x2 - 1][y2])

    aaie = str(list_1[x1][y2]) + str(list_1[x2][y1])
    return aaie


#去除空格
for i in str_1:
    str_2 += i.strip(" ")

#去掉重复和j
for i in str_2:
    if i in str_3:
        pass
    elif i == "j":
        pass
    else:
        str_3 += i

#填完密钥出现的字母后，若还有空余，就填字母表中剩余的字母（按字母表顺序）
for i in str_4:
    if i in str_3:
        pass
    else:
        str_5 += i
str_3 += str_5

flag = ""

#分为 5x5 的数组
for i in range(5):
    list_1.append(str_3[i * 5 : i * 5 + 5])

for i in range(0, len(str_6), 2):
    flag += zhongheng(str(str_6[i]), str(str_6[i+1]))
print "flag: " + flag
```

跑一下，也能得到相同的结果

## Day 5

### 填空题

**题干：**拿到一个填空题，到底该填什么？答案的格式是key{xxxxx}，所以答案是

**解题步骤：**

没有任何提示，百度一下rfc4042，得知是utf9或者utf18编码的

所以先安装个utf9库

python解一下

```python
import utf9
f = open('flag_is_here_rfc4042', 'rb')
s = ''
for line in f:
    s += line
    
print utf9.utf9decode(s)
```

得到：

```
_____*((__//__+___+______-____%____)**((___%(___-_))+________+(___%___+_____+_______%__+______-(______//(_____%___)))))+__*(((________/__)+___%__+_______-(________//____))**(_*(_____+_____)+_______+_________%___))+________*(((_________//__+________%__)+(_______-_))**((___+_______)+_________-(______//__)))+_______*((___+_________-(______//___-_______%__%_))**(_____+_____+_____))+__*(__+_________-(___//___-_________%_____%__))**(_________-____+_______)+(___+_______)**(________%___%__+_____+______)+(_____-__)*((____//____-_____%____%_)+_________)**(_____-(_______//_______+_________%___)+______)+(_____+(_________%_______)*__+_)**_________+_______*(((_________%_______)*__+_______-(________//________))**_______)+(________/__)*(((____-_+_______)*(______+____))**___)+___*((__+_________-_)**_____)+___*(((___+_______-______/___+__-_________%_____%__)*(___-_+________/__+_________%_____))**__)+(_//_)*(((________%___%__+_____+_____)%______)+_______-_)**___+_____*((______/(_____%___))+_______)*((_________%_______)*__+_____+_)+___//___+_________+_________/___
```

感觉应该是数学表达式，猜想下划线的个数代表数字，这样就能构成数学算式

再写个脚本，计算一下结果

```python
s = '_____*((__//__+___+______-____%____)**((___%(___-_))+________+(___%___+_____+_______%__+______-(______//(_____%___)))))+__*(((________/__)+___%__+_______-(________//____))**(_*(_____+_____)+_______+_________%___))+________*(((_________//__+________%__)+(_______-_))**((___+_______)+_________-(______//__)))+_______*((___+_________-(______//___-_______%__%_))**(_____+_____+_____))+__*(__+_________-(___//___-_________%_____%__))**(_________-____+_______)+(___+_______)**(________%___%__+_____+______)+(_____-__)*((____//____-_____%____%_)+_________)**(_____-(_______//_______+_________%___)+______)+(_____+(_________%_______)*__+_)**_________+_______*(((_________%_______)*__+_______-(________//________))**_______)+(________/__)*(((____-_+_______)*(______+____))**___)+___*((__+_________-_)**_____)+___*(((___+_______-______/___+__-_________%_____%__)*(___-_+________/__+_________%_____))**__)+(_//_)*(((________%___%__+_____+_____)%______)+_______-_)**___+_____*((______/(_____%___))+_______)*((_________%_______)*__+_____+_)+___//___+_________+_________/___'
ul = s[0]
cnt = 0
exp = ''
for i in s:
    if i is ul:
        cnt += 1
    else:
        if cnt != 0:
            exp += str(cnt)
            cnt = 0
            exp += i
        else:
            exp += i
if cnt != 0:
	exp += str(cnt)
exp = exp.replace('//', '/')
print exp
key = eval(exp)
print key
```

得到算式：

```
5*((2/2+3+6-4%4)**((3%(3-1))+8+(3%3+5+7%2+6-(6/(5%3)))))+2*(((8/2)+3%2+7-(8/4))**(1*(5+5)+7+9%3))+8*(((9/2+8%2)+(7-1))**((3+7)+9-(6/2)))+7*((3+9-(6/3-7%2%1))**(5+5+5))+2*(2+9-(3/3-9%5%2))**(9-4+7)+(3+7)**(8%3%2+5+6)+(5-2)*((4/4-5%4%1)+9)**(5-(7/7+9%3)+6)+(5+(9%7)*2+1)**9+7*(((9%7)*2+7-(8/8))**7)+(8/2)*(((4-1+7)*(6+4))**3)+3*((2+9-1)**5)+3*(((3+7-6/3+2-9%5%2)*(3-1+8/2+9%5))**2)+(1/1)*(((8%3%2+5+5)%6)+7-1)**3+5*((6/(5%3))+7)*((9%7)*2+5+1)+3/3+9+9/3
```

key算出来是：5287002131074331513

瞎捣鼓了半天，发现应该将key转为16进制，再转为字符

```python
key = 5287002131074331513
hk = hex(key)[2:]
ck = ''
for i in range(len(hk) / 2):
	ck += chr(int(hk[i * 2 : i * 2 + 2], 16))
print ck
```

运行一下得到

```
I_4m-k3y
```

所以flag就是key{I_4m-k3y}
